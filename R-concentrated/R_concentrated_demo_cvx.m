close all;
clear all;
rand('seed',1);
randn('seed',1);

compute_full_eigen=0;

% graph
G = gsp_david_sensor_network(500);
%G = gsp_airfoil();
%G=gsp_minnesota(1);

if compute_full_eigen
   G = gsp_compute_fourier_basis(G);
else
   G = gsp_estimate_lmax(G);
end


% filter describing band
lower=0; %sensor low
upper=.635;
%lower=.85; %sensor mid
%upper=2.55;
%upper=.49; % make sure edge are in gaps

%minn low
%lower=0;
%upper=.059;

%minn mid

%lower=.072;
%upper=.131;
h = @(x) (x>=lower & x<upper);

figure;
gsp_plot_filter(G,h);
title('Spectral Band');
if ~compute_full_eigen
    param.grid_order=1000;
    param.order=50;
    [~, JCH]=gsp_jackson_cheby_coeff(lower, upper, [0,G.lmax], param.order);
    hold on;
    xx=0:.001:G.lmax;
    plot(xx,gsp_cheby_eval(xx,JCH,[0,G.lmax]),'r','LineWidth',3);
end

% signal generated by filtering random noise
r = rand(G.N,1);
if compute_full_eigen
    y = gsp_filter(G,h,r);
else
    y=gsp_cheby_op(G,JCH,r);
end
% 
max_val=max(abs(y));
param.vertex_size = 100;
param.climits = [-max_val,max_val];
figure;
gsp_plot_signal(G, y, param);
title('Original R-Concentrated Signal');

% if ~compute_full_eigen
%     G = rmfield(G,'U');
%     G = rmfield(G,'e');
%     G = rmfield(G,'lmax');
%     G = gsp_estimate_lmax(G);
% end
% 
% if compute_full_eigen
%     G = gsp_compute_fourier_basis(G);
% end

% sampling and reconstruction parameters
L = ceil(2*log(G.N));
L=100;

if compute_full_eigen
    %extra_samps=0
    nb_meas = sum(h(G.e)); %+extra_samps; % m: num eigenvalues in band, will need to estimate if don't have exact eigenvalues
else
    % may need to do something better here. why not spectrum slice at those
    % two points? replace this with filtering as we need to do that anyhow
    %G=gsp_spectrum_cdf_approx(G);
    %nb_meas=floor((G.spectrum_cdf_approx(upper)-G.spectrum_cdf_approx(lower))*G.N);
    
%     P=symamd(G.L);
%     [Parent, Lp, PO, PIn, flopcount] = ldlsymbol_extra(G.L,P);
%     mat_lower=G.L-lower*speye(G.N);
%     [~, HD_lower]=ldlnumeric(mat_lower,Lp,Parent,PO,PIn);
%     below_lower=sum(diag(HD_lower)<0);
%     mat_upper=G.L-upper*speye(G.N);
%     [~, HD_upper]=ldlnumeric(mat_upper,Lp,Parent,PO,PIn);
%     below_upper=sum(diag(HD_upper)<0);
%     nb_meas=below_upper-below_lower;
   
    nb_meas=36; % sensor low
  %nb_meas=42; % sensor band
  
  %minn
  %nb_meas=50;
  
end



% plot coherence vector
%co=(max(abs(G.U)'))';
%figure;
%gsp_plot_signal(G, co, param);

%% Sampling Matrix

%% Sampling Distribution
[weights, P_min_half] = compute_sampling_weights(G,L,h);

figure;
param.climits = [0,max(weights)];
gsp_plot_signal(G, weights, param);
title('Sampling Weights');
set(gca,'FontSize',24);

if compute_full_eigen
    subband_ids = ones(G.N,1);
    subband_ids(G.e>=lower)=2;
    subband_ids(G.e>upper)=3;
    part_param.greedy_init=1;
    partition_ids = part_mat(G.U,subband_ids,part_param);
    selected=find(partition_ids==2);
    num_selected=length(selected);
    M=sparse(1:num_selected,selected,ones(num_selected,1),num_selected,G.N);
else
    [M, selected] = build_sampling_matrix(G, weights, nb_meas);
end

% plot selected vertices
selected_signal=zeros(G.N,1);
selected_signal(selected)=1;

param.climits = [0,1];
figure;
gsp_plot_signal(G, selected_signal, param);
title('Selected Vertices');

%% Reconstruct
gamma = 10*G.N; % regularization parameter
precondition=1;
tic
z = approx_reconstruct(G, y, weights, selected, gamma , lower,upper,precondition);
time1=toc
tic
z2 =approx_reconstruct_new_method(G, y, weights, selected, gamma , lower,upper);
time2=toc


tau1=10;
g_tilde_L=gsp_cheby_op(G,JCH,eye(G.N));

cvx_begin
   variable z4(G.N)
   minimize( norm((1./sqrt(weights(selected))).*(M*z4-y(selected)) - 1/tau1 * log(-z'*g_tilde_L*z) ))
cvx_end


% plot reconstruction
figure;
param.climits = [-max_val,max_val];
gsp_plot_signal(G, z, param);
title('Reconstruction');

% plot reconstruction 2
figure;
param.climits = [-max_val,max_val];
gsp_plot_signal(G, z2, param);
title('Reconstruction 2');

% plot reconstruction 2
figure;
gsp_plot_signal(G, z4, param);
title('Reconstruction 4');

% plot reconstruction error
error=abs(y-z);
param.climits = [0, max(error)];
figure;
gsp_plot_signal(G, error, param);
title('Reconstruction Error');

% plot reconstruction error 2
error2=abs(y-z2);
param.climits = [0, max(error2)];
figure;
gsp_plot_signal(G, error2, param);
title('Reconstruction Error 2');


% plot reconstruction error 4
error4=abs(y-z4);
param.climits = [0, max(error4)];
figure;
gsp_plot_signal(G, error4, param);
title('Reconstruction Error 4');

% average of two methods
z3=(z+z2)/2;

% plot reconstruction 3
figure;
param.climits = [-max_val,max_val];
gsp_plot_signal(G, z3, param);
title('Reconstruction 3');

% plot reconstruction error 3
error3=abs(y-z3);
param.climits = [0, max(error3)];
figure;
gsp_plot_signal(G, error3, param);
title('Reconstruction Error 3');

se1=sum(error.^2)
se2=sum(error2.^2)
se3=sum(error3.^2)
se4=sum(error4.^2)

% 

%g_tilde_L=gsp_filter(G,h,eye(G.N),param);
[1-diag(g_tilde_L),sum(abs(g_tilde_L-diag(diag(g_tilde_L))),2)]
min(eig(eye(G.N)-g_tilde_L))
wd = zeros(G.N,1);
wd(selected)=1./weights(selected);
B=diag(wd);
LHS=B+gamma*(eye(G.N)-g_tilde_L);
cond(LHS)
RHS=zeros(G.N,1);
RHS(selected)=y(selected)./weights(selected);
z0=LHS\RHS;

cc=@(x) cond(B+x*(eye(G.N)-g_tilde_L));
xxx=[10,100,500,1000,5000,10000,100000];
ccc=zeros(size(xxx));
for i=1:length(xxx)
    ccc(i)=cc(xxx(i));
end
ccc